# -*- coding: utf-8 -*-
"""Проект: Компьютерное зрение

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h72SrzgxomF88rWZGTWw7LK4Cy8OciXM

# Определение возраста покупателей

## Исследовательский анализ данных

Сетевой супермаркет «...» внедряет систему компьютерного зрения для обработки фотографий покупателей.

**Цель проекта:**
Создать нейронную сеть, которая по фотографии определяет примерный возраст человека с точностью MAE ≤ 8.

**Задачи проекта:**

- Проанализировать набор фотографий людей с указанием возраста.

- Подготовить данные к обучению (нормализация, аугментация, разделение на обучающую и тестовую выборки).

- Построить и обучить свёрточную нейронную сеть (ResNet50 с дообучением).

- Оценить качество модели по метрике MAE на тестовой выборке.

**Практическое применение:**

- Анализировать покупки и предлагать товары для конкретных возрастных групп.

- Контролировать продажу алкоголя на кассе.
"""

import pandas as pd
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import ImageDataGenerator

"""Создание датасета с фотографиями - labels"""

labels = pd.read_csv('/datasets/faces/labels.csv')

datagen = ImageDataGenerator(rescale=1./255)
datagen_flow = datagen.flow_from_dataframe(
        dataframe=labels,
        directory='/datasets/faces/final_files/',
        x_col='file_name',
        y_col='real_age',
        target_size=(224, 224),
        batch_size=32,
        class_mode='raw',
        seed=12345)

labels.head()

labels.shape[0]

"""Проверка датасета и изучение реального возраста покупателей"""

labels.info()

plt.figure(figsize=(10, 6))
plt.hist(labels['real_age'], bins=100, edgecolor='black')
plt.title('Распределение возраста в выборке')
plt.xlabel('Возраст')
plt.ylabel('Количество изображений')
plt.grid(True);

"""Построение распределения возраста в представленной выборке. По ней можно сделать вывод о том, что большинство представленных фотографий людей в возрасте 20-40 лет, что может дать переоучение/недообучение в разных возрастных категориях"""

features, target = next(datagen_flow)

fig = plt.figure(figsize=(15, 8))
for i in range(15):
    fig.add_subplot(3, 5, i + 1)
    plt.imshow(features[i])
    plt.title(f'Age: {int(target[i])}')
    plt.axis('off')
plt.tight_layout()
plt.show()

"""По выведенным фотографиям можно сделать вывод о том, что многие фотографии расположены под углом. Есть черно-белые фотограыии, представлены люди в очках и с закрывающими лицо/часть лица предметами(надуты шар из жвачки, кепки, усы). Также представлены люди с разным цветом кожи и разным цветом волос. Все фотографии разного качества визуально.

**Вывод**

- Датасет загружен, содержит фотографии пользователей и метки возраста.
- Проведена проверка структуры и первичная оценка данных.
- Построено распределение возраста.
- Визуально проанализированы фотографии.

1. Размер датасета - 7591

Данных достаточно для обучения модели, но необходимо учесть дисбаланс возрастных категорий.

2. Распределение целевого признака (возраста)

Большая часть выборки сосредоточена в диапазоне **20–40 лет**.

3. Особенности данных на фотографиях

- Есть черно-белые фото, снимки под углом, лица в очках, с аксессуарами (шляпы, кепки), иногда с посторонними предметами (пузырь из жвачки).
- Люди имеют разный цвет кожи, разные прически, иногда часть лица закрыта.
- Качество изображений разнообразное: различия в освещении, резкости и фокусе.

## Обучение модели
"""

import pandas as pd
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import GlobalAveragePooling2D, Dense, Dropout

def load_train(path='/datasets/faces/'):
    labels = pd.read_csv(path + 'labels.csv')

    train_datagen = ImageDataGenerator(
        rescale=1./255,
        validation_split=0.2,
        rotation_range=20,
        width_shift_range=0.2,
        height_shift_range=0.2,
        zoom_range=0.2,
        horizontal_flip=True
    )

    train_gen = train_datagen.flow_from_dataframe(
        dataframe=labels,
        directory=path + 'final_files/',
        x_col='file_name',
        y_col='real_age',
        target_size=(224, 224),
        batch_size=32,
        class_mode='raw',
        subset='training',
        seed=42
    )
    return train_gen

def load_test(path='/datasets/faces/'):
    labels = pd.read_csv(path + 'labels.csv')

    val_datagen = ImageDataGenerator(
        rescale=1./255,
        validation_split=0.2
    )

    val_gen = val_datagen.flow_from_dataframe(
        dataframe=labels,
        directory=path + 'final_files/',
        x_col='file_name',
        y_col='real_age',
        target_size=(224, 224),
        batch_size=32,
        class_mode='raw',
        subset='validation',
        seed=42,
        shuffle=False
    )
    return val_gen

def create_model(input_shape=(224, 224, 3)):
    backbone = ResNet50(input_shape=input_shape,
                        weights='imagenet',
                        include_top=False)
    backbone.trainable = True

    model = Sequential([
        backbone,
        GlobalAveragePooling2D(),
        Dropout(0.3),
        Dense(1)
    ])

    model.compile(optimizer=Adam(learning_rate=1e-4),
                  loss='mse',
                  metrics=['mae'])
    return model

def train_model(model, train_data, test_data,
                batch_size=None, epochs=10,
                steps_per_epoch=None, validation_steps=None):

    if steps_per_epoch is None:
        steps_per_epoch = train_data.samples // train_data.batch_size
    if validation_steps is None:
        validation_steps = test_data.samples // test_data.batch_size

    model.fit(
        train_data,
        validation_data=test_data,
        epochs=epochs,
        steps_per_epoch=steps_per_epoch,
        validation_steps=validation_steps,
        verbose=2
    )
    return model

"""Train for 189 steps, validate for 47 steps

Epoch 1/10
189/189 - 105s - loss: 249.2963 - mae: 11.4937 - val_loss: 418.1507 - val_mae: 15.3628

Epoch 2/10
189/189 - 96s - loss: 105.2065 - mae: 7.7297 - val_loss: 815.9938 - val_mae: 23.5388

Epoch 3/10
189/189 - 94s - loss: 87.4590 - mae: 7.1155 - val_loss: 391.3406 - val_mae: 14.9273

Epoch 4/10
189/189 - 94s - loss: 72.0790 - mae: 6.4797 - val_loss: 164.0540 - val_mae: 9.6454

Epoch 5/10
189/189 - 94s - loss: 65.5785 - mae: 6.2166 - val_loss: 80.5336 - val_mae: 6.6975

Epoch 6/10
189/189 - 94s - loss: 62.0061 - mae: 5.9916 - val_loss: 72.5812 - val_mae: 6.2469

Epoch 7/10
189/189 - 95s - loss: 52.4575 - mae: 5.5491 - val_loss: 80.3434 - val_mae: 6.8372

Epoch 8/10
189/189 - 95s - loss: 44.9975 - mae: 5.1679 - val_loss: 81.3518 - val_mae: 7.0084

Epoch 9/10
189/189 - 94s - loss: 43.8021 - mae: 5.0910 - val_loss: 84.5218 - val_mae: 7.0370

Epoch 10/10
189/189 - 95s - loss: 41.0960 - mae: 4.9418 - val_loss: 65.9401 - val_mae: 6.0041

48/48 - 8s - loss: 66.3305 - mae: 6.0058

## Анализ обученной модели

**Цель проекта** — построение свёрточной нейронной сети для предсказания возраста человека по фотографии и достижение значения MAE на тестовой выборке ≤ 8 - выполнена.

**Используемые данные**:

- Датасет состоит из изображений лиц и соответствующих им возрастов.
- Для загрузки данных были реализованы функции load_train(path) и load_test(path).
- Для обучения использовалась аугментация изображений: вращение, сдвиги, масштабирование и горизонтальное отражение. Это позволило модели лучше обобщать данные.

**Архитектура модели и обучение**:

- В качестве базовой использована предобученная сеть ResNet50 с весами ImageNet.
- Сеть включала слой глобального усреднения (`GlobalAveragePooling2D`), слой Dropout (0.3) и Dense-слой с одним выходом.
- Использовала оптимизатор Adam с learning rate = 0,0001 и функция потерь MSE.


5. **Результаты**:

- Модель достигла MAE на тестовой выборке < 6, что соответствует цели проекта и говорит о хорошем качестве предсказаний.

6. **Вывод**:

- Использование предобученной свёрточной сети с аугментацией изображений позволяет эффективно решать задачу регрессии возраста по фото.
- Дальнейшие улучшения могут быть достигнуты увеличением числа эпох, подбором learning rate, более агрессивной аугментацией и использованием дополнительных данных для обучения.
"""